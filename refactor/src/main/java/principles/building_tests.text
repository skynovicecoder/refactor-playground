If you want to refactor, the essential precondition is having solid tests.

The Value of Self-testing Code:
Make sure all tests are fully automatic and that they check their own results.

A suite of tests is a powerful bug detector that decapitates the time it takes to find bugs.

The JUnit Testing Framework
The testing framework I use is JUnit, an open-source testing framework developed by Erich Gamma and Kent Beck

Run your tests frequently. Localize tests whenever you compile—every test at least every day.

Unit and Functional Tests

Unit Test:
I write them to improve my productivity as a programmer.
Making the quality assurance department happy is just a side effect.
Unit tests are highly localized.
Each test class works within a single package.
It tests the interfaces to other packages, but beyond that it assumes the rest just works.

Functional tests
They are written to ensure the software as a whole works.
They provide quality assurance to the customer and don’t care about programmer productivity.
They should be developed by a different team, one who delights in finding bugs.
This team uses heavyweight tools and techniques to help them do this.
Functional tests typically treat the whole system as a black box as much as possible.
In a GUI-based system, they operate through the GUI.
In a file or database update program, the tests just look at how the data is changed for certain inputs.

When functional testers, or users, find a bug in the software, at least two things are needed to fix it.
1. Of course you have to change the production code to remove the bug.
2. But you should also add a unit test that exposes the bug.
Note: When you get a bug report, start by writing a unit test that exposes the bug.

Adding More Tests
It is better to write and run incomplete tests than not to run complete tests.
Don’t forget to test that exceptions are raised when things are expected to go wrong.
Don’t let the fear that testing can’t catch all bugs stop you from writing the tests that will catch most bugs.


